from fastapi import FastAPI, Request, Depends, Form
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, RedirectResponse , JSONResponse
from app.core.database import engine, Base, get_db
from app.api import tasks as tasks_api
from app.core import queue_manager
from sqlalchemy.orm import Session
from app.logging.logger import logging
from app.core.data_processor import load_and_filter_movie_csv, fetch_tmdb_movies, fetch_and_process_data
# from app.core.utils import save_movie_records
from typing import Optional
from app.core import models
import json

# Create database tables if they don't exist
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Data Sourcing and Visualization App")

# Mount static files (CSS, JS)
app.mount("/static", StaticFiles(directory="app/static"), name="static")

# Setup templates
templates = Jinja2Templates(directory="app/templates")

# Include API routers
app.include_router(tasks_api.router, prefix="/api", tags=["Tasks"])

# --- Event Handlers for Worker ---
@app.on_event("startup")
async def startup_event():
    logging.info("Starting application and background worker...")
    queue_manager.start_worker()

@app.on_event("shutdown")
async def shutdown_event():
    logging.info("Stopping background worker...")
    queue_manager.stop_worker()
    logging.info("Application shutdown complete.")

# --- Frontend Route ---
@app.get("/", response_class=HTMLResponse, name="index")
async def index(request: Request):
    """Serves the main HTML page."""
    return templates.TemplateResponse("index.html", {"request": request})


@app.post("/submit-source-a")
async def submit_source_a(
    request: Request,
    start_year: Optional[int] = Form(None),
    end_year: Optional[int] = Form(None),
    # genre: Optional[str] = Form(None),
    min_rating: Optional[float] = Form(None),
    language: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """Handles form submission for Source A (CSV)."""
    logging.info("Received request for /submit-source-a")

    data = await request.form()
    print(data)
    # 1. Extract Filters
    filters = {
        "start_year": data["start_year_a"],
        "end_year": data["end_year_a"] if "end_year_a" in data.keys() else None,
        # "genre": data["genres_a"].split(",") if "genres_a" in data.keys() else [],
        "min_rating": data["avg_votes_a"] if "avg_votes_a" in data.keys() else None,
        "language": data["language_a"] if "language_a" in data.keys() else None,
    }
    logging.info(f"Filters received: {filters}")

    db_task = models.Task(status=models.TaskStatus.PENDING, filters=filters)
    db.add(db_task)
    db.commit()
    db.refresh(db_task)  # Get the task ID generated by the database
    task_id = db_task.id
    
    queue_manager.add_task_to_queue(task_id=task_id, filters=filters)
    logging.info(f"Created task {task_id} for Source A with filters: {filters}")
    logging.info(f"Added task {task_id} with filters: {filters} to DB")


    # # 3. Create a Task
    # db_task = models.Task(status=models.TaskStatus.COMPLETED, filters=filters)
    # db.add(db_task)
    # db.commit()
    # db.refresh(db_task)
    
    # 4. Save Data to Database
    # save_movie_records(db, db_task.id, filtered_df)

    # 5. Redirect or Return Response
    return JSONResponse(content={"task_id": task_id})



@app.post("/submit-source-b")
async def submit_source_b(
    request: Request,
    start_year: Optional[int] = Form(None),
    end_year: Optional[int] = Form(None),
    genres_tmdb: Optional[str] = Form(None),
    min_rating_tmdb: Optional[float] = Form(None),
    db: Session = Depends(get_db),
):
    """Handles form submission for Source B (TMDb API)."""
    logging.info("Received request for /submit-source-b")

    # 1. Extract Filters
    filters = {
        "start_year": start_year,
        "end_year": end_year,
        "genres_tmdb": [g.strip() for g in genres_tmdb.split(",")] if genres_tmdb else [],
        "min_rating_tmdb": min_rating_tmdb,
    }
    logging.info(f"Filters received: {filters}")

    # 2. Fetch and Process Data
    unified_df = fetch_tmdb_movies(filters)

    if unified_df is None or unified_df.empty:
        logging.warning("No data found after filtering.")
        return templates.TemplateResponse(
            "index.html", {"request": request, "message": "No data found matching the filters."}
        )

    # 3. Create a Task
    db_task = models.Task(status=models.TaskStatus.COMPLETED, filters=filters)
    db.add(db_task)
    db.commit()
    db.refresh(db_task)
    logging.info(f"Created task {db_task.id} for Source B with filters: {filters}")

    # 4. Save Data to Database
    # save_movie_records(db, db_task.id, unified_df)

    # 5. Redirect or Return Response
    return RedirectResponse(request.url_for("index"), status_code=303)
